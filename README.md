<h1>Section 6 Project 2</h1>

<h2>Overview</h2>

In the previous activity, we added a ```Point``` class, and fixed code to use it properly. What we did is known as [refactoring](http://en.wikipedia.org/wiki/Code_refactoring). We changed code that was bad, and made it better. In the process we made our code easier to use. However, there is still one more refactoring we have to do. We mentioned sometime back, that we have not tested code which computes the count of squares.

Let's try to understand why we have not been able to test that code. As things stand right now, the placement of mines is randomly determined in the ```Board``` class' constructor. This means, to be able to figure out if the count computed by the ```Board``` class is correct, we would have to take the random mine placement generated by the ```Board``` class and recompute the counts in the test case. Once we have this data, we could compare the counts computed in the test case with the counts computed in the ```Board``` class. Do you see the absurdity of this ? We  are testing some logic in production code with similar logic, in test code. This is totally wrong. We could end up in a situation where two negatives make a positive, thus flagging the code as good when it could be faulty. Ideally, test code should have as little computation as possible. Keep it simple, because we do not test the tests. 

If clients of the ```Board``` class could control how the mines are created in a board, then it could, when needed, set mines at predefined places, and test the count of squares accordingly.

So, the real problem is - how do we change our code to ensure that determination of mines on a board does **not** happen in the ```Board``` class?

We want to take control of determining mine locations away from the ```Board``` class and give it to the class which instantiates ```Board```. This is also known as [Inversion of Control](http://stackoverflow.com/questions/3058/what-is-inversion-of-control), or IoC. Inversion of control can be achieved in many ways. [Dependency Injection](http://stackoverflow.com/questions/130794/what-is-dependency-injection) is one of them. We will explain what this means, by showing you how to change the ```Board``` class.

Code Snippet 1, below, shows the existing ```Board``` class (as it is), with the logic for determining mine locations is in the constructor.

    public Board() {
        this.squares = new Square[MAX_ROWS][MAX_COLS];
	    // intitialize squares and set mines
	    for(int row=0; row<MAX_ROWS; row++) {
		    for(int col=0; col<MAX_COLS; col++) {
			    Square square = new Square();
			    // determine if this Square should be a mine
			    long ctms = System.nanoTime();
			    if(ctms % 2 != 0) {
				    square.setMine(true);
			    }
			    squares[row][col] = square;
		    }
	    }
        // ...
    }

_**Code Snippet 1**_

If we change the code, such that the constructor of  ```Board``` is given an object, which determines mine locations, then the control of determining mine locations is taken away from the ```Board``` class, and is given to the object which instantiates ```Board```. We show this in Code Snippet 2. 

    public Board(MineInitializationStrategy mineInitializationStrategy) {
	    this.squares = new Square[MAX_ROWS][MAX_COLS];
	    // intitialize squares
	    for(int row=0; row<MAX_ROWS; row++) {
		    for(int col=0; col<MAX_COLS; col++) { 				
			    squares[row][col] = new Square();
		    }
	    }
	
	    // TODO: Use the mineInitializationStrategy to set mines 
        // in required squares
	    // ...
    }

_**Code Snippet 2**_

As shown in Code Snippet 2 above, the Board class takes an instance of  ```MineInitializationStrategy``` in it's constructor. The responsibility of this interface is to provide a list of mines for a Board of a given size. It fulfills this responsibility with a method called ```mines```.  

Once the ```MineInitializationStrategy``` is given to ```Board```, it can invoke the mines method of ```MineInitializationStrategy```, to get the list of mines. ```Board``` can then use this list to set appropriate squares as mines. The real power of this code comes from the fact that we can create different subclasses of ```MineInitializationStrategy``` for different purposes. Some subclasses which come to mind are ```HardcodedMineInitializationStrategy``` (can be used in testing), and ```RandomMineINitializationStrategy``` (to be used in production). 

Thus we are able to use the [Strategy Design Pattern](http://sourcemaking.com/design_patterns/strategy) along with IoC, and use different mine initialization strategies for different situations.

Shown below in Code Snippet 3, is an interface which represents the mine initialization strategy.

    public interface MineInitializationStrategy {
	
	    /**
	     * Determines the points which should be mines for a Board with the specified max size
	     * @param maxSize The Point which represents the outer edge of the Board
	     * @return A List containing Point objects for mines
	     */
	    public List<Point> mines(Point maxSize);	
    }

_**Code Snippet 3**_

We can create two implementations of the interface shown in Code Snippet 3. One will be used for test cases and will return a hard coded list of mines, and the other will be used for production code and will return a random list of mines.

<h2>Steps For This Project</h2>

 1. You will notice several compile errors in the project. This is because we have changed the signature of the constructor of ```Board```. We have fixed compile errors in the test cases, but you have to fix a few errors that still exist in production code.
 1. Run ```AllTests``` and verify that 39 tests are run, our of which 1 test fails - ```BoardTest.testSquareCount```.
 1. Follow _TODO:_ instructions in the ```mines``` method of ```RandomMineInitializationStrategy```
 1. Follow _TODO:_ instructions in the constructor of ```Board``` and implement the missing code
 1. Implement the test case ```BoardTest.testSquareCount```.
 1. Run ```AllTests``` and verify that all tests pass
 
 <h2>Things To Notice</h>
 1. Notice the ```setUp``` method of ```BoardTest```, and notice that it instantiates ```Board``` with a ```HardcodedMineInitializationStrategy```. Also search for the code in ```UI.java``` which instantiates a ```Board``` instance and find out which subclass of ```MineInitializationStrategy``` it uses.
 1. Isn't it much easier to use ```Point``` objects as compared to how we worked earlier ?
  