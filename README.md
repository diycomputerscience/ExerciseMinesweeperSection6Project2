<h1>Section 6 Project 2</h1>

<h2>Overview</h2>

In the previous activity, we added a ```Point``` class, and fixed some code to use it. What we did is known as refactoring. We changed code that was bad, and made it better. In the process we made our code easier to use. However, there is still one more refactoring we have to do. We mentioned sometime back, that we have not tested logic which computes the count, for in the Board class' constructor.

Let's try to understand why we have not been able to test that code. As things stand right now, the placement of mines is randomly determined in the ```Board``` class' constructor. This means, to be able to figure out if the count computed by the ```Board``` class is correct, we would have to take the random mine placement generated by the ```Board``` class and recompute the counts in the test case. Then we would compare the counts computed in the test case with the counts computed in the ```Board``` class. Do you see the absurdity of this ? We  are testing some logic in production code with similar logic, in test code. This is totally wrong. Test code should have as little computation as possible, because we do not test the tests. 

If clients of the ```Board``` class could control how the mines are created in a board, then it could when needed set mines at predefined places, and test the count of squares accordingly.

So, the real problem is - how do we change our code to ensure the determination of mines on a board does **not** happen in the ```Board``` class. We would then be able to have full control over the location of mines on the board.

We want to take control of determining mine locations away from the ```Board``` class and give it to the class which instantiates ```Board```. This is also known as [Inversion of Control](http://stackoverflow.com/questions/3058/what-is-inversion-of-control), or IoC. Inversion of control can be achieved in many ways. Dependency Injection is one of them. We will explain what this means, by showing you how to change the ```Board``` class.

Code Snippet 1, below, shows the existing ```Board``` class (as it is), with the logic for determining mine locations is in the constructor.

    public Board() {
        this.squares = new Square[MAX_ROWS][MAX_COLS];
	    // intitialize squares and set mines
	    for(int row=0; row<MAX_ROWS; row++) {
		    for(int col=0; col<MAX_COLS; col++) {
			    Square square = new Square();
			    // determine if this Square should be a mine
			    long ctms = System.nanoTime();
			    if(ctms % 2 != 0) {
				    square.setMine(true);
			    }
			    squares[row][col] = square;
		    }
	    }
        // ...
    }

_**Code Snippet 1**_

If we change the code, such that the constructor of  ```Board``` is given an object, which determines mine locations, then the control of determining mine locations is taken away from the ```Board``` class, and is given to the object which instantiates ```Board```. We shod this in Code Snippet 2. 

    public Board(MineInitializationStrategy mineInitializationStrategy) {
	    this.squares = new Square[MAX_ROWS][MAX_COLS];
	    // intitialize squares
	    for(int row=0; row<MAX_ROWS; row++) {
		    for(int col=0; col<MAX_COLS; col++) { 				
			    squares[row][col] = new Square();
		    }
	    }
	
	    // TODO: Use the mineInitializationStrategy to set mines 
        // in required squares
	    // ...
    }

_**Code Snippet 2**_

As shown in Code Snippet 2 above, the Board class takes an instance of  ```MineInitializationStrategy``` in it's constructor. The responsibility of this interface is to provide a list of mines for a Board of a given size. It fulfills this responsibility with a method called mines.  

Once the ```MineInitializationStrategy``` is given to ```Board```, it can invoke the mines method of ```MineInitializationStrategy```, to get the list of mines. ```Board``` can then use this list to set appropriate squares as mines. The real power of this code comes from the fact that we can create different subclasses of ```MineInitializerStrategy``` for different pruposes. Some subclasses which come to mind are ```HardcodedMineInitializationStrategy```, and ```RandomMineINitializationStrategy```. While instantiating a Board instance, in different situations (such as testing, production, etc), we can give it the approporiate subclass of the ```MineInitializerStrategy```.

Thus we are able to use the [Strategy Design Pttern](http://sourcemaking.com/design_patterns/strategy) along with IoC, and use different mine initialization strategies for different situations.

Shoen below in Code Snippet 3, is an interface which represents the mine initialization strategy.

    public interface MineInitializationStrategy {
	
	    /**
	     * Determines the points which should be mines for a Board with the specified max size
	     * @param maxSize The Point which represents the outer edge of the Board
	     * @return A List containing Point objects for mines
	     */
	    public List<Point> mines(Point maxSize);	
    }

_**Code Snippet 3**_

We can create two implementations of the interface shown in Code Snippet 3. One will be used for test cases and will return a hard coded list of mines, and the other will be used for production code and will return a random list of mines.

<h2>Steps For This Project</h2>

 1. You will notice several compile errors in the project. This is because we have changed the signature of the constructor of ```Board```. We have fixed compile errors in the test cases, but you have to fix a few errors that still exist in production code.
 1. Run ```AllTests``` and verify that 39 tests are run, our of which 1 test fails - ```BoardTest.testSquareCount```.
 1. Follow _TODO:_ instructions in the ```mines``` method of ```RandomMineInitializationStrategy```
 1. Follow _TODO:_ instructions in the constructor of ```Board``` and implement the missing code
 1. Implement the test case ```BoardTest.testSquareCount```
 1. Run ```AllTests``` and verify that all tests pass
 